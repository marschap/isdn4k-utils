/*
 * ISDN accounting for isdn4linux.
 *
 * Copyright 1996 by Stefan Luethje (luethje@sl-gw.lake.de)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

#define _CONFFILE_C_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/stat.h>
#include <unistd.h>

#include "conffile.h"

/****************************************************************************/

static int (*print_msg)(const char *, ...) = printf;

/****************************************************************************/

static int Write_Lines(section *Section, FILE *fp, const char *FileName, int Level);
static section *Read_Lines(section *Section, FILE *fp, const char *FileName, int *Line, int Flags);
static char *Find_Section(char* String);
static int Find_Entry(const char *FileName, int Line, char* String, char** Variable, char** Value);
static entry* Append_Entry(entry** Entry, char *Variable, char* Value, section *SubSection, int Flag);
static void free_entry(entry *Ptr);
static void free_cfile(cfile **cfiles);
static const char *Pre_String(int Level);
static int Compare_Sections(section* sec1, section *sec2, char ***variables);
static section *Insert_Section(section **main_sec, section **ins_sec, char ***variables, int flags);
static int Merge_Sections(section **main_sec, section **ins_sec, char ***variables, int flags);
static int Find_Include(section **Section, char* String, int Flags);
static section* _Get_Section_From_Path(char **array, section* Section, section **RetSection, entry **RetEntry);
static entry* _Get_Entry_From_Path(char **array, entry* Entry, section **RetSection, entry **RetEntry);
static section* Get_Section_From_Path(section* NewSection, char *Path, entry **RetEntry);
static char* Delete_Chars(char *String, char *Quote);
static int Set_Ret_Code(char *Value, int Type, void **Pointer);

/****************************************************************************/

void set_print_fkt_for_conffile(int (*new_print_msg)(const char *, ...))
{
	print_msg = new_print_msg;
}

/****************************************************************************/

section *write_file(section *Section, const char *FileName, char *Program, char* Version)
{
	FILE *fp;
	time_t t =time(NULL);


	if ((fp = fopen(FileName, "w")) == NULL)
	{
		print_msg("Can't write `%s' (%s)\n",FileName,strerror(errno));
		return NULL;
	}

	fprintf(fp,"###############################################################################\n");
	fprintf(fp,"#\n");
	fprintf(fp,"# File %s generated by %s %s on %s",FileName,Program,Version,ctime(&t));
	fprintf(fp,"#\n");
	fprintf(fp,"###############################################################################\n");

	Write_Lines(Section,fp,FileName,0);

  fclose(fp);
	return NULL;
}

/****************************************************************************/

static int Write_Lines(section *Section, FILE *fp, const char *FileName, int Level)
{
	entry *Ptr;


	while (Section != NULL)
	{
		fprintf(fp,"\n%s[%s]\n", Pre_String(Level), Section->name);

		Ptr = Section->entries;

		while (Ptr != NULL)
		{
			if (Ptr->name)
			{
				fprintf(fp,"%s%s %c ", Pre_String(Level), Ptr->name, C_EQUAL);

				if (Ptr->value != NULL)
					fprintf(fp,"%s\n",Quote_Chars(Ptr->value));
				else
				if (Ptr->subsection != NULL)
				{
					fprintf(fp,"%c\n", C_BEGIN_SUBSECTION);
					Write_Lines(Ptr->subsection,fp,FileName,Level+1);
					fprintf(fp,"%s%c\n", Pre_String(Level), C_END_SUBSECTION);
fflush(fp);
				}
				else
					print_msg("Warning in file `%s': There is no value for `%s'!\n", FileName, Ptr->name);
			}

			Ptr = Ptr->next;
		}

		Section = Section->next;
	}
	return 0;
}

/****************************************************************************/

static const char *Pre_String(int Level)
{
	static int  OldLevel = -1;
	static char PreString[SHORT_STRING_SIZE];

	if (Level != OldLevel)
	{
		memset(PreString,' ',Level*2);
		PreString[Level*2] = '\0';
		OldLevel = Level;
	}

	return PreString;
}

/****************************************************************************/

section *read_file(section *Section, const char *FileName, int Flags)
{
	int   Line = 0;
	FILE *fp;
	section  *RetCode = NULL;


	if ((fp = fopen(FileName, "r")) == NULL)
	{
		if (!(Flags & C_NO_WARN_FILE))
			print_msg("Can't open `%s' (%s)\n",FileName,strerror(errno));

		return NULL;
	}

	RetCode = Read_Lines(Section, fp, FileName, &Line, Flags);

	fclose(fp);
	return RetCode;
}

/****************************************************************************/

static section *Read_Lines(section *Section, FILE *fp, const char *FileName, int *Line, int Flags)
{
	char  String[BUFSIZ];
	char *Sectionname, *Variable, *Value;
	int   Res;
	section *Ptr = Section;


	while (FGets(String, BUFSIZ, fp, Line) != NULL)
	{
		if ((Sectionname = Find_Section(String)) != NULL)
		{
			if ((Ptr = Set_Section(&Section,Sectionname,C_OVERWRITE | C_WARN | Flags)) == NULL)
			{
				free_section(Section);
				return NULL;
			}
		}
		else
		if (Find_Include(&Section,String,Flags) == 0)
		{
			Ptr = NULL;
		}
		else
		if ((Res = Find_Entry(FileName,*Line,String,&Variable,&Value)) == 0)
		{
			if (Ptr == NULL)
			{
				print_msg("Error in file `%s', line %d: there is no section for variable `%s'!\n",FileName,*Line,Variable);
			}
			else
			{
				if (*Value == C_BEGIN_SUBSECTION && Not_Space(Value+1) == NULL)
				{
					if (Set_SubSection(Ptr,Variable,Read_Lines(NULL,fp,FileName,Line,Flags),C_OVERWRITE | C_WARN) == NULL)
					{
						free_section(Section);
						return NULL;
					}
				}
				else
					if (Set_Entry(Ptr,NULL,Variable,Value,C_OVERWRITE | C_WARN) == NULL)
					{
						free_section(Section);
						return NULL;
					}
			}
		}
		else
		if (Res == -1 && *(Kill_Blanks(String)) == C_END_SUBSECTION)
			return Section;
		else
		if (Res == -1)
			print_msg("Error in file `%s', line %d: there is no valid token!\n",FileName,*Line);
	}

	return Section;
}

/****************************************************************************/

static char *Find_Section(char* String)
{
	char *Ptr = NULL;
	char Help[SHORT_STRING_SIZE];


	strcpy(Help,String);
	String = Kill_Blanks(Help);

	if (*String == '\0' || *String != C_BEGIN_SECTION)
		return NULL;

	Ptr = String + strlen(String)-1;
	if (Ptr == strchr(String,C_END_SECTION))
	{
		*Ptr = '\0';
		Delete_Chars(String+1,S_ALL_QUOTE);
		return String+1;
	}

	return NULL;
}

/****************************************************************************/

static int Find_Entry(const char *FileName, int Line, char* String, char** Variable, char** Value)
{
	char *Ptr = NULL;


	if (String == NULL || Variable == NULL || Value == NULL)
		return -1;

	*Variable = *Value = NULL;

	if ((Ptr = strchr(String,C_EQUAL)) == NULL)
		return -1;
	else
	{
		*Ptr++ ='\0';
		Kill_Blanks(String);
		Delete_Chars(String,S_ALL_QUOTE);

		if (*String == '\0')
		{
			print_msg("Error in file `%s', line %d: There is no variable name!\n", FileName, Line);
			return -2;
		}
		else
			*Variable = String;
	}

	if ((Ptr = Not_Space(Ptr)) == NULL)
	{
		print_msg("Error in file `%s', line %d: There is no value for `%s'!\n", FileName, Line, *Variable);
		return -2;
	}

	*Value    = Ptr;

	return 0;
}

/****************************************************************************/

static int Find_Include(section **Section, char* String, int Flags)
{
	section *Ptr = NULL;
	char Help1[SHORT_STRING_SIZE];

	strcpy(Help1,String);
	Kill_Blanks(Help1);

	if (!strncasecmp(S_KEY_INCLUDE,Help1,strlen(S_KEY_INCLUDE)) &&
	    Help1[strlen(S_KEY_INCLUDE)] == C_BEGIN_INCLUDE         &&
	    Help1[strlen(Help1)-1]       == C_END_INCLUDE             )
	{
		Help1[strlen(Help1)-1] = '\0';
		if ((Ptr = read_file(*Section,Help1+strlen(S_KEY_INCLUDE)+1,Flags)) == NULL)
			return -1;
		else
			*Section = Ptr;

		return 0;
	}

	return -1;
}

/****************************************************************************/

section *Set_Section(section **Section, char *Sectionname, int Flag)
{
	char _Sectionname[SHORT_STRING_SIZE];
	section **Ptr = Section;

	if (Sectionname != NULL)
	{
		strcpy(_Sectionname,Sectionname);
		To_Upper(_Sectionname);
	}
	else
		return NULL;

	while ((*Ptr) != NULL)
	{
		if (!(Flag & C_NOT_UNIQUE) && !strcmp((*Ptr)->name,_Sectionname))
		{
			if (Flag & C_OVERWRITE)
			{
				section *Ptr2 = (*Ptr)->next;
				(*Ptr)->next = NULL;
				free_section(*Ptr);
				*Ptr = Ptr2;

				if (Flag & C_WARN)
					print_msg("Will overwrite section `%s'!\n", _Sectionname);
			}
			else
				return NULL;
		}
		else
			Ptr = &((*Ptr)->next);
	}

	if ((*Ptr = (section*) calloc(1,sizeof(section))) == NULL)
		return NULL;

	if (((*Ptr)->name = strdup(_Sectionname)) == NULL)
	{
		free_section(*Ptr);
		*Ptr = NULL;
		return NULL;
	}

 	return *Ptr;
}

/****************************************************************************/

section *Set_SubSection(section *Section, char *Variable, section *SubSection, int Flag)
{
	char _Variable[SHORT_STRING_SIZE];


	if (Variable != NULL)
	{
		strcpy(_Variable,Variable);
		To_Upper(_Variable);
	}
	else
		return NULL;

	if (Append_Entry(&(Section->entries),_Variable,NULL,SubSection,Flag) == NULL)
		return NULL;
	else
		return SubSection;
}

/****************************************************************************/

entry *Set_Entry(section *Section, char *Sectionname, char *Variable, char *Value, int Flag)
{
	char _Variable[SHORT_STRING_SIZE];
	section  *Ptr;


	if (Variable != NULL)
	{
		strcpy(_Variable,Variable);
		To_Upper(_Variable);
	}
	else
		return NULL;

	if (Sectionname != NULL)
	{
		if ((Ptr = Get_Section(Section,Sectionname)) == NULL)
			return NULL;
	}
	else
		Ptr = Section;

	return Append_Entry(&(Ptr->entries),_Variable,Value,NULL,Flag);
}

/****************************************************************************/

entry* Get_Entry(entry* Entry, char *Variable)
{
	while (Entry != NULL && strcmp(Entry->name,Variable))
		Entry = Entry->next;

	return Entry;
}

/****************************************************************************/

section* Get_Section(section* Section, char *Sectionname)
{
	while (Section != NULL && strcmp(Section->name,Sectionname))
		Section = Section->next;

	return Section;
}

/****************************************************************************/

section* Get_SubSection(section* Section, char *Variable)
{
	entry*  Ptr;

	if ((Ptr = Get_Entry(Section->entries,Variable)) == NULL)
		return NULL;

	return Ptr->subsection;
}

/****************************************************************************/

static entry* Append_Entry(entry** Entry, char *Variable, char* Value, section *SubSection, int Flag)
{
	if (Entry == NULL)
		return NULL;

	if ((Value != NULL && SubSection != NULL) || (Value == NULL && SubSection == NULL))
		return NULL;

	while ((*Entry) != NULL)
	{
		if (!strcmp((*Entry)->name,Variable))
		{
			if (Flag & C_OVERWRITE)
			{
				entry *Ptr = (*Entry)->next;
				(*Entry)->next = NULL;
				free_entry(*Entry);
				*Entry = Ptr;

				if (Flag & C_WARN)
					print_msg("Will overwrite entry `%s'!\n", Variable);
			}
			else
			if (Flag & C_APPEND && SubSection != NULL && (*Entry)->subsection != NULL)
			{
				section **Section = &((*Entry)->subsection);

				while(*Section != NULL)
					Section = &((*Section)->next);

				*Section = SubSection;
				return *Entry;
			}
			else
				return NULL;
		}
		else
			Entry = &((*Entry)->next);
	}

	if ((*Entry = (entry*) calloc(1,sizeof(entry))) == NULL)
		return NULL;

	if (((*Entry)->name = strdup(Variable)) == NULL)
	{
		free_entry(*Entry);
		*Entry = NULL;
		return NULL;
	}

	if (Value != NULL)
	{
    if (((*Entry)->value = strdup(Value)) == NULL)
		{
			free_entry(*Entry);
			*Entry = NULL;
			return NULL;
		}
	}
	else /* SubSection != NULL */
		(*Entry)->subsection = SubSection;

	return *Entry;
}

/****************************************************************************/

static void free_entry(entry *Ptr)
{
	if (Ptr == NULL)
		return;

	free_entry(Ptr->next);
	free_section(Ptr->subsection);
	free(Ptr->name);
	free(Ptr->value);
	free(Ptr);
}

/****************************************************************************/

void free_section(section *Ptr)
{
	if (Ptr == NULL)
		return;

	free_section(Ptr->next);
	free_entry(Ptr->entries);
	free(Ptr->name);
	free(Ptr);
}

/****************************************************************************/

section *Del_Section(section **Section, char *Sectionname)
{
	section **RetCode = Section;
	section *Ptr;

	if (Section == NULL)
		return NULL;

	if (Sectionname != NULL)
		while ((*Section) != NULL && strcmp((*Section)->name,Sectionname))
			Section = &((*Section)->next);

	if (*Section)
	{
		Ptr = *Section;
		if (Section == RetCode)
			RetCode = &((*Section)->next);

		*Section = (*Section)->next;
		Ptr->next = NULL;
		free_section(Ptr);
	}

	Section = RetCode;
	return *RetCode;
}

/****************************************************************************/

static section *Insert_Section(section **main_sec, section **ins_sec, char ***variables, int flags)
{
	section *Ptr = NULL;
	
	if ((*ins_sec)->next != NULL)
	{
		print_msg("%s","Can only insert one entry at time!\n");
		return NULL;
	}

	if (main_sec == NULL)
	{
		print_msg("%s","Main section is emtpy!\n");
		return NULL;
	}

	while(*main_sec != NULL)
	{
		if (!Compare_Sections(*main_sec,*ins_sec,variables))
		{
			if ((!(flags & C_NOT_UNIQUE) && variables == NULL) ||
			    (flags & C_OVERWRITE)                            )
			{
				Ptr = *main_sec;
				*main_sec = *ins_sec;
				*ins_sec = NULL;
				(*main_sec)->next = Ptr->next;
				Ptr->next = NULL;
				free_section(Ptr);
				return *main_sec;
			}

		}

		main_sec = &((*main_sec)->next);
	}

	*main_sec = *ins_sec;
	*ins_sec = NULL;
	(*main_sec)->next = NULL;
	
	return *main_sec;
}

/****************************************************************************/

static int Compare_Sections(section* sec1, section *sec2, char ***variables)
{
	int i;
	entry *Entry1 = NULL;
	entry *Entry2 = NULL;


	if (sec1 == NULL || sec2 == NULL)
		return -1;

	if (variables == NULL)
	{
		if (!strcmp(sec1->name,sec2->name))
			return 0;
	}
	else
	{
		for (i=0; variables[i] != NULL && variables[i][0] != NULL && variables[i][1] != NULL; i++)
		{
			if (!strcmp(sec1->name,sec2->name)                               &&
			    !strcmp(sec1->name,variables[i][0])                          &&
			    (Entry1 = Get_Entry(sec1->entries,variables[i][1])) != NULL  &&
			    Entry1->value != NULL                                        &&
			    (Entry2 = Get_Entry(sec2->entries,variables[i][1])) != NULL  &&
			    Entry2->value != NULL && !strcmp(Entry1->value,Entry2->value)  )
				return 0;
		}
	}

	return -1;
}

/****************************************************************************/

static int Merge_Sections(section **main_sec, section **ins_sec, char ***variables, int flags)
{
	if (main_sec == NULL)
	{
		print_msg("%s","Main section is emtpy!\n");
		return -1;
	}

	if (ins_sec == NULL)
	{
		print_msg("%s","Insert section is emtpy!\n");
		return -1;
	}

	if (*ins_sec == NULL)
	{
		print_msg("%s","Insert section element is emtpy!\n");
		return -1;
	}

	if((*ins_sec)->next != NULL)
		Merge_Sections(main_sec,&((*ins_sec)->next),variables,flags);

	Insert_Section(main_sec,ins_sec,variables,flags);

	if (*ins_sec != NULL)
	{
		free_section(*ins_sec);
		*ins_sec = NULL;
	}

	return 0;
}

/****************************************************************************/

static void free_cfile(cfile **cfiles)
{
	cfile **cptr;

	if (cfiles != NULL)
	{
		cptr = cfiles;
		while (*cptr != NULL)
		{
			free((*cptr)->name);
			free(*cptr);
			cptr++;
		}
		free(cfiles);
		cfiles = NULL;
	}

	return;
}

/****************************************************************************/

/* filenum gibt an, aus wievielen Dateien gelesen werden soll. Die Dateinamen
   sind dann in files zu finden. Wenn filnum == -1, dann muss der letzte Eintrag
   von files[x] == NULL sein.
   variable wird benoetigt, um eine Section eindeutig zu identifizieren zu
   koennen. Da viele Sections in der Regel den gleichen Namen verwenden
   (z. B. [NUMBER], [MSN]), muessen die einzelnen Eintraege ja eindeutig
   erkannt werden koennen, wie es ein Key bei einer Datenbank kann. Dieses
   kann dann ueber die Eintraege gemacht werden koennen (z.B. NUMBER=0815).
   Wenn man in variables nun z.B. "NUMBER" uebergibt, wird sichergestellt,
   das nur einmal ein Eintrag NUMBER=1234 unter allen Sectionen [NUMBER]
   existiert. Dieses wird benoetigt, wenn es mehrere Config-Dateien gibt, die
   durchsucht/eingelesen werden muessen. Z.B. /etc/isdn/isdn.conf, ~/.isdn.
   In dieser Reihenfolge sollte auch die Variable files belegt sein (von
   globalen runter zu lokalen Configdateien.
   Die Variable flags sollte _immer_ auf 'C_OVERWRITE|C_NOT_UNIQUE' gesetzt
   werden, anderes macht hier zur Zeit keinen Sinn.
   main_sec darf _NIE_ unintilisiert sein und muss beim ersten mal NULL
   enthlten!!!!
*/

section *read_files(section **main_sec, char** files, char ***variables, int flags)
{
	int newread = 0;
	static cfile **cfiles = NULL;
	static struct stat FileStat;
	section *ins_sec = NULL;
	int i;

	if (files != NULL)
	{
		newread = 1;

		free_cfile(cfiles);
		cfiles = NULL;

		for (i=0; files[i] != NULL; i++)
		{
			if ((cfiles = (cfile**) realloc(cfiles,sizeof(cfile*)*(i+2))) == NULL)
			{
				print_msg("%s","Can not allocate memory!\n");
				return NULL;
			}

			if ((cfiles[i] = (cfile*) calloc(1,sizeof(cfile))) == NULL)
			{
				print_msg("%s","Can not allocate memory!\n");
				return NULL;
			}

			cfiles[i+1] = NULL;

			if (stat(files[i],&FileStat) != 0 && !(flags & C_NO_WARN_FILE))
			{
				print_msg("Can not open file `%s': %s!\n",files[i],strerror(errno));
				return NULL;
			}

			cfiles[i]->name = strdup(files[i]);
			cfiles[i]->modtime = FileStat.st_mtime;
		}

	}
	else
	{
		if (cfiles == NULL)
		{
			print_msg("%s","There is no file!\n");
			return NULL;
		}
		else
		{
			for (i=0; cfiles[i] != NULL; i++)
			{
				if (stat(cfiles[i]->name,&FileStat) != 0)
				{
					if (!(flags & C_NO_WARN_FILE))
					{
						print_msg("Can not open file `%s': %s!\n",cfiles[i]->name,strerror(errno));
						return NULL;
					}
				}
				else
				{
					if (cfiles[i]->modtime != FileStat.st_mtime)
					{
						cfiles[i]->modtime = FileStat.st_mtime;
						newread = 1;
						break;
					}
				}
			}
		}
	}

	if (newread)
	{
		free_section(*main_sec);
		*main_sec = NULL;

		for (i=0; cfiles[i] != NULL; i++)
		{
			if (*main_sec == NULL)
			{
				*main_sec = read_file(NULL,cfiles[i]->name,flags);
			}
			else
			{
				if ((ins_sec = read_file(NULL,cfiles[i]->name,flags)) != NULL)
					Merge_Sections(main_sec,&ins_sec,variables,flags);
			}
		}
	}

	return *main_sec;
}

/****************************************************************************/

#if 0
/* Filtert aus den gesamten Sectionen die heraus, die in secnames
   enthalten sind. Wenn also nur die Sectionen [MSN] und [NUMBER] benoetigt
   werden, dann werden diese hier uebergeben("MSN","NUMBER"), und secnum
   auf 2 gesetzt. secnum hat die gleich Bedeutung wie filenum in
   read_files().
*/

int Filter_Sections(section **sec, char** secnames)
{
	int i;
	int del;
	section *Ptr;


	if (sec == NULL)
	{
		print_msg("%s","Section is emtpy!\n");
		return -1;
	}

	while(*sec != NULL)
	{
		del = 1;

		for (i=0; secnames[i] != NULL && *sec != NULL; i++)
		{
			if (!strcmp(secnames[i],(*sec)->name))
				del = 0;
		}

		if (del == 1)
		{
			Ptr = *sec;
			*sec = (*sec)->next;
			Ptr->next = NULL;
			free_section(Ptr);
		}

		if (*sec != NULL && del == 0)
			sec = &((*sec)->next);
	}

	return 0;
}
#endif

/****************************************************************************/

#if 0 /* AK:24-Feb-97 */
int Filter_Sections(section **sec, char** path)
{
	int j,i = 0;
	int del;
	section *Ptr;
	section *retsec;
	entry   *retent;
	char   **array;
	char   **array2;


	if (path == NULL || path[0] == NULL)
		return -1;

	if (sec == NULL)
	{
		print_msg("%s","Section is emtpy!\n");
		return -1;
	}

	while(*sec != NULL)
	{
		del = 1;

		for (i=0; path[i] != NULL && *sec != NULL && del == 1; i++)
		{
			if (_Get_Section_From_Path(sec,path[i],&retsec,&retent) == sec)
			{
				if ((array = String_to_Array(path,C_SLASH)) == NULL)
					return NULL;

				j=0;
				while(array[j] != NULL);

				del_Array(array);
				
				del = 0;
			}
		}

		if (del == 1)
		{
			Ptr = *sec;
			*sec = (*sec)->next;
			Ptr->next = NULL;
			free_section(Ptr);
		}

		if (*sec != NULL && del == 0)
			sec = &((*sec)->next);
	}

	return 0;
}
#endif

/****************************************************************************/

/* Nur die erlaubten Entries sind in entnames enthalten */
/* Filter aus _allen_  Sections die Eintraege heraus, die in entnames
   enthalten sind. So kann man in alles Sections z.B. nur die Entries
   NUMBER=blabla und ALIAS=blabla behalten ("NUMBER","ALIAS")
   uebergeben. entnum hat die gleiche Bedeutung wie filenum in
   read_files().
*/

int Filter_Entries(section **sec, char ** entnames)
{
	int i;
	int del;
	entry **ent;
	entry *Ptr;
	section *Ptr2;

	if (*sec == NULL)
		return -1;

	while (*sec != NULL)
	{
		ent = &((*sec)->entries);

		while(*ent != NULL)
		{
			del = 1;

			for (i=0; entnames[i] != NULL && *ent != NULL; i++)
			{
				if ((*ent)->name != NULL && !strcmp(entnames[i],(*ent)->name))
					del = 0;
			}

			if (del == 1)
			{
				Ptr = *ent;
				*ent = (*ent)->next;
				Ptr->next = NULL;
				free_entry(Ptr);
			}

			if (*ent != NULL && del == 0)
				ent = &((*ent)->next);
		}

		if ((*sec)->entries == NULL)
		{
			Ptr2 = *sec;
			*sec = (*sec)->next;
			Ptr2->next = NULL;
			free_section(Ptr2);
		}
		else
			sec = &((*sec)->next);
	}

	return 0;
}

/****************************************************************************/

static section* Get_Section_From_Path(section* NewSection, char *Path, entry **Entry)
{
	static section *RootSection = NULL;
	static section *RetSection = NULL;
	static entry *RetEntry = NULL;
	static char **array = NULL;


	if (Path != NULL && NewSection != NULL)
	{
		RootSection = NewSection;
		RetSection = NULL;
		RetEntry = NULL;

		if (array != NULL)
			del_Array(array);

		if ((array = String_to_Array(Path,C_SLASH)) == NULL)
			return NULL;

		if (array[0] == NULL)
			return NULL;
	}
	else if (Path == NULL && NewSection == NULL    &&
	         (RootSection == NULL || array == NULL)  )
		return NULL;
	else if (Path != NULL || NewSection != NULL)
		return NULL;

	
	if ((RootSection = _Get_Section_From_Path(array,RootSection,&RetSection,&RetEntry)) == NULL)
		RetSection = NULL;

	if (Entry != NULL)
		*Entry = RetEntry;

	return RetSection;
}

/****************************************************************************/

static entry* _Get_Entry_From_Path(char **array, entry* Entry, section **RetSection, entry **RetEntry)
{
	int index;
	int found = 0;
	int found_first = 0;
	char **array2 = NULL;


	if (array[0] == NULL)
		return NULL;

	if ((array2 = String_to_Array(array[0],C_OR)) == NULL)
			return NULL;

	while(found == 0 && Entry != NULL)
	{
		index = 0;

		if (Entry->name != NULL)
		{
			while(array2[index] != NULL && found == 0)
			{
				if (match(array2[index],Entry->name,F_IGNORE_CASE) == 0)
				{
					if (array[1] == NULL)
					{
						if (Entry->value != NULL && *RetEntry != Entry &&
						    (*RetEntry == NULL || found_first != 0)      )
						{
							found = 1;
							*RetEntry = Entry;
						}
						else
							if (*RetEntry == Entry)
								found_first = 1;
					}
					else
					{
						if (_Get_Section_From_Path(array+1,Entry->subsection,RetSection,RetEntry) != NULL)
						{
							found = 1;

							if (array[2] == NULL)
								*RetEntry = Entry;
						}
					}
				}

				index++;
			}
		}

		if (found == 0)
			Entry = Entry->next;
	}

	if (found == 0 && found_first != 0)
		*RetEntry = NULL;

	del_Array(array2);
	return Entry;
}

/****************************************************************************/

static section* _Get_Section_From_Path(char **array, section* Section, section **RetSection, entry **RetEntry)
{
	int index;
	int found = 0;
	int found_first = 0;
	char **array2 = NULL;


	if (array[0] == NULL)
		return NULL;

	if ((array2 = String_to_Array(array[0],C_OR)) == NULL)
			return NULL;

	while(found == 0 && Section != NULL)
	{
		index = 0;

		if (Section->name != NULL)
		{
			while(array2[index] != NULL && found == 0)
			{
		    if (match(array2[index],Section->name,F_IGNORE_CASE) == 0)
		  	{
					if (array[1] == NULL)
					{
						if (*RetSection != Section && (*RetSection == NULL || found_first != 0))
						{
							found = 1;
							*RetSection = Section;
						}
						else
							if (*RetSection == Section)
								found_first = 1;
					}
					else
					{
						if (_Get_Entry_From_Path(array+1,Section->entries,RetSection,RetEntry) != NULL)
						{
							found = 1;

							if (array[2] == NULL)
								*RetSection = Section;
						}
					}
				}

				index++;
			}
		}

		if (found == 0)
			Section = Section->next;
	}

	if (found == 0 && found_first != 0)
		*RetSection = NULL;

	del_Array(array2);
	return Section;
}

/****************************************************************************/

section* Get_Section_Match(section* Section, char *Path,
                           char* Value, int  (*_match)(char*, char*), entry **RetEntry)
{
	entry *Entry;


	while ((Section = Get_Section_From_Path(Section,Path,&Entry)) != NULL)
	{
		if (RetEntry != NULL)
			*RetEntry = Entry;

		if (Entry->subsection != NULL)
		{
			if (Value == NULL)
				return Entry->subsection;
/* Die naechsten Zeilen sind fuer Syntax-DAU's auskommentiert: 
   NUMBER={
     [blabla]
   }
   fuehrt zum Abbruch!

			else
				return NULL;
*/
		}
		else
		{
			if (Value == NULL)
				return NULL;
			else
			{
				if ((_match == NULL && !strcmp(Entry->value,Value)) ||
				    !_match(Entry->value,Value)                       )
					return Section;
			}
		}

		Section = NULL;
		Path = NULL;
	}

	return NULL;
}

/****************************************************************************/

char *Get_Value(section *Section, char *Path)
{
	entry *Entry;

	while ((Section = Get_Section_From_Path(Section,Path,&Entry)) != NULL)
	{
		if (Entry->value != NULL)
			return Entry->value;

		Section = NULL;
		Path = NULL;
	}

	return NULL;
}

/****************************************************************************/

static int Set_Ret_Code(char *Value, int Type, void **Pointer)
{
	int RetCode = -1;


	if (Pointer == NULL || Value == NULL)
		return -1;

	switch (Type)
	{
		case R_TYPE_LONG  :
		case R_TYPE_INT   : if (is_integer(Value,(long int*) Pointer))
		                    	RetCode = 0;
		                    else
		                    	*((long int*)Pointer) = 0;
		                    break;

		case R_TYPE_DOUBLE: if (is_double(Value,(double*) Pointer))
		                    	RetCode = 0;
		                    else
		                    	*((double*)Pointer) = 0.0;
		                    break;

		case R_TYPE_CHAR  : *((char*)Pointer) = Value[0];
		                    if (strlen(Value) == 1)
		                    	RetCode = 0;
		                    break;

		case R_TYPE_STRING: *((char**)Pointer) = Value;
		                    RetCode = strlen(Value);
		                    break;

		default           : break;
	}

	return RetCode;
}

/****************************************************************************/

int _Get_Type_Value(section *Section, char *Path, int Type, void **Pointer)
{
	register int   RetCode = -1;
	auto     char *Ptr;


	while (RetCode == -1 && (Ptr = Get_Value(Section,Path)) != NULL)
		RetCode = Set_Ret_Code(Ptr,Type,Pointer);

	return RetCode;
}

/****************************************************************************/

int _Get_Type_Match(section *Section, char *Path, char* Pattern,
                            int  (*_match)(char*, char*), int Type, void **Pointer)
{
	entry *Entry;


	if (Get_Section_Match(Section,Path,Pattern,_match,&Entry) == NULL ||
	    Entry != NULL || Entry->name == NULL                            )
		return -1;

	return Set_Ret_Code(Entry->name,Type,Pointer);
}

/****************************************************************************/

static char* Delete_Chars(char *String, char *Quote)
{
	char *Ptr = String;

	if (Ptr == NULL)
		return NULL;

	while ((Ptr = Strpbrk(Ptr,Quote)) != NULL)
	{
		print_msg("Invalid character (`%s') in string `%s'. Character ignored!\n",Quote,String);

		do
			*Ptr = *(Ptr + 1);
		while(*Ptr++ != '\0');
	}

	return String;
}

/****************************************************************************/

